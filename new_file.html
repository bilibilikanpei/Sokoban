<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title>推箱子</title>
		<style type="text/css">
			html,
			body {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
				position: relative;
			}
			
			.box {
				width: 50px;
				height: 50px;
				background-color: red;
				position: absolute;
			}
			
			#people {
				width: 50px;
				height: 50px;
				font-size: 2.5em;
				text-align: center;
				line-height: 45px;
				border: 2px solid black;
				box-sizing: border-box;
				position: absolute;
				top: 0px;
				left: 0px;
				z-index: 100;
			}
			
			.target {
				width: 50px;
				height: 50px;
				background-color: lawngreen;
				position: absolute;
			}
			
			.overlap {
				background-color: deepskyblue;
				transform: scale(1.1);
			}
			
			.wall {
				width: 50px;
				height: 50px;
				background-color: gray;
				position: absolute;
			}
		</style>
	</head>

	<body>
		<script type="text/javascript">
			class People {
				constructor() {
					this.top = 0; //纵坐标
					this.left = 0; //横坐标
					this.people = null; //记录player节点
					this.lastDir = 0; //记录上次操作
				}
				creatPeople(top, left) {
					if(!!this.people) {
						return;
					}
					this.top = top;
					this.left = left;
					var people = document.createElement('div');
					people.id = 'people';
					people.innerText = '人';
					//					初始化位置
					people.style.top = this.top + 'px';
					people.style.left = this.left + 'px';
					this.people = people;
					//					放入body中
					document.body.appendChild(people);
				}
				//操作人移动方法
				handler(e) {
					switch(e.keyCode) {
						case 37:
							this.left -= 50;
							this.people.style.left = this.left + 'px';
							this.lastDir = e.keyCode;
							break;
						case 38:
							this.top -= 50;
							this.people.style.top = this.top + 'px';
							this.lastDir = e.keyCode;
							break;
						case 39:
							this.left += 50;
							this.people.style.left = this.left + 'px';
							this.lastDir = e.keyCode;
							break;
						case 40:
							this.top += 50;
							this.people.style.top = this.top + 'px';
							this.lastDir = e.keyCode;
							break;
					}
				}
			}

			class Boxes {
				constructor() {
					this.positionList = []; //保存箱子位置
					this.boxesList = []; //保存箱子节点
				}
				//生成箱子
				creatBox(top, left) {
					//					检查
					this.positionList.forEach((boxPosi, index) => {
						if(boxPosi.top === top && boxPosi.left === left) {
							return;
						}
					});
					//                  箱子位置
					var position = {
						top,
						left
					};
					//					箱子位置记录到列表
					this.positionList.push(position);
					//					创建div
					let box = document.createElement('div');
					//					添加className
					box.classList.add('box');
					//					初始化位置
					box.style.top = position.top + 'px';
					box.style.left = position.left + 'px';
					//					放入body中
					document.body.appendChild(box);
					//					把箱子节点记录到列表中
					this.boxesList.push(box);
				}
				move(e, Walls) {
					//					imgBoxIndex要大于0即代表找到要推动的箱子
					if(Walls.imgBoxIndex >= 0) {
						switch(e.keyCode) {
							case 37:
								this.positionList[Walls.imgBoxIndex].left -= 50;
								this.boxesList[Walls.imgBoxIndex].style.left = this.positionList[Walls.imgBoxIndex].left + 'px';
								break;
							case 38:
								this.positionList[Walls.imgBoxIndex].top -= 50;
								this.boxesList[Walls.imgBoxIndex].style.top = this.positionList[Walls.imgBoxIndex].top + 'px';
								break;
							case 39:
								this.positionList[Walls.imgBoxIndex].left += 50;
								this.boxesList[Walls.imgBoxIndex].style.left = this.positionList[Walls.imgBoxIndex].left + 'px';
								break;
							case 40:

								this.positionList[Walls.imgBoxIndex].top += 50;
								this.boxesList[Walls.imgBoxIndex].style.top = this.positionList[Walls.imgBoxIndex].top + 'px';
								break;
							default:
						}
					}
				}
				checkBox(e, walls) {
					//		墙已经阻挡人和箱子 检查箱子是否阻止箱子
					//		计算箱子将要移动到的位置
					//		imgBoxIndex要大于0即代表找到要推动的箱子
					if(walls.imgBoxIndex > -1) {
						let imgBoxPo = null;
						switch(e.keyCode) {
							case 37:
								imgBoxPo = {
									top: walls.imgBoxPo.top,
									left: walls.imgBoxPo.left - 50
								}
								break;
							case 38:
								imgBoxPo = {
									top: walls.imgBoxPo.top - 50,
									left: walls.imgBoxPo.left
								}
								break;
							case 39:
								imgBoxPo = {
									top: walls.imgBoxPo.top,
									left: walls.imgBoxPo.left + 50
								}
								break;
							case 40:
								imgBoxPo = {
									top: walls.imgBoxPo.top + 50,
									left: walls.imgBoxPo.left
								}
								break;
						}
						for(let i = 0, len = this.positionList.length; i < len; i++) {
							if(this.positionList[i].top === imgBoxPo.top && this.positionList[i].left === imgBoxPo.left) {
								//被挡住了 就返回false阻止移动
								return false;
							}
						}
					}
					return true;
				}
			}

			class Targets {
				constructor() {
					//					目标列表
					this.positionList = [];
					//				    节点列表
					this.targetsList = [];
				}
				//				生成目标
				creatTarget(top, left) {
					var position = {
						top,
						left
					};
					this.positionList.push(position);

					let target = document.createElement('div');
					target.classList.add('target');
					//					初始化位置
					target.style.top = position.top + 'px';
					target.style.left = position.left + 'px';
					document.body.appendChild(target);
					this.targetsList.push(target);
				}
				//				检查目标位置是否与箱子重叠
				check(boxes) {
					for(let i = 0, iLen = this.positionList.length; i < iLen; i++) {
						for(let j = 0, jLen = boxes.positionList.length; j < jLen; j++) {
							if(this.positionList[i].top === boxes.positionList[j].top && this.positionList[i].left === boxes.positionList[j].left) {
								this.targetsList[i].classList.add('overlap');
								return;
							} else {
								this.targetsList[i].classList.remove('overlap');
							}
						}
					}
				}
			}

			class Walls {
				constructor() {
					this.positionList = []; //墙的位置
					this.wallsList = []; //墙的节点
					this.forbidList = []; //禁止移动的列表
					this.imgBoxPo = null; //假想的箱子位置  没用过 在箱子阻挡判断时能用
					this.imgBoxIndex = -1; //找到假想的箱子的序列 有序号就够了
				}
				creatWall(top, left) {
					//					检查
					this.positionList.forEach((wallPosi, index) => {
						if(wallPosi.top === top && wallPosi.left === left) {
							return;
						}
					});
					//                  箱子位置
					var position = {
						top,
						left
					};
					//					箱子位置记录到列表
					this.positionList.push(position);
					//					创建div
					let wall = document.createElement('div');
					//					添加className
					wall.classList.add('wall');
					//					初始化位置
					wall.style.top = position.top + 'px';
					wall.style.left = position.left + 'px';
					//					放入body中
					document.body.appendChild(wall);
					//					把箱子节点记录到列表中
					this.wallsList.push(wall);

					//					记录禁止移动列表
					this.forbidList = this.forbidList.concat({
						top,
						left: left - 50,
						dir: 39 //右
					}, {
						top: top + 50,
						left,
						dir: 38 //上
					}, {
						top,
						left: left + 50,
						dir: 37 //左
					}, {
						top: top - 50,
						left,
						dir: 40 //下
					})
				}
				check(e, people, boxes) {
					for(let i = 0; i < this.forbidList.length; i++) {
						if(this.forbidList[i].top === people.top && this.forbidList[i].left === people.left && this.forbidList[i].dir === e.keyCode) {
							//							禁止移动
							return false;
						}
						//确实找到假想的箱子才可以进行判断
						if(this.findBox(e, people, boxes)) {
							if(this.forbidList[i].top === this.imgBoxPo.top && this.forbidList[i].left === this.imgBoxPo.left && this.forbidList[i].dir === e.keyCode) {
								//									禁止移动
								//this.imgBoxIndex = -1 walls找到的箱子经过了验证，但还是被强挡住 这里需要重置为-1
								//不在这里重置了
								return false;
							}
						}
					}
					return true;
				}
				findBox(e, people, boxes) {
					//						首先找出会移动的箱子
					switch(e.keyCode) {
						case 37:
							this.imgBoxPo = {
								top: people.top,
								left: people.left - 50
							}
							break;
						case 38:
							this.imgBoxPo = {
								top: people.top - 50,
								left: people.left
							}
							break;
						case 39:
							this.imgBoxPo = {
								top: people.top,
								left: people.left + 50
							}
							break;
						case 40:
							this.imgBoxPo = {
								top: people.top + 50,
								left: people.left
							}
							break;
						default:
						//这个默认return修复 按键不是上下左右就无须判断移动了
							return false;
					}
					//					遍历是否有这个位置的箱子
					for(let i = 0; i < boxes.positionList.length; i++) {
						if(boxes.positionList[i].top === this.imgBoxPo.top && boxes.positionList[i].left === this.imgBoxPo.left) {
							//找到序号为i的箱子
							this.imgBoxIndex = i;
							return true;
						}
					}
					return false;
				}
			}

			var Sokoban = {
				people: new People(),
				boxes: new Boxes(),
				targets: new Targets(),
				walls: new Walls()
			}

			Sokoban.people.creatPeople(200, 250);
			Sokoban.boxes.creatBox(100, 100);
			Sokoban.boxes.creatBox(100, 150);
			Sokoban.targets.creatTarget(200, 200)
			Sokoban.walls.creatWall(150, 150);

			document.body.onkeydown = (e) => {
				//				能阻止移动的情况一:墙挡住人或者箱子
				//				能组织移动的情况二:箱子移动的方向还有箱子
				if(Sokoban.walls.check(e, Sokoban.people, Sokoban.boxes)) {
					if(Sokoban.boxes.checkBox(e, Sokoban.walls)) {
						Sokoban.people.handler(e);
						Sokoban.boxes.move(e, Sokoban.walls); //walls中的imgBoxIndex会被重置未-1
						Sokoban.targets.check(Sokoban.boxes);
					};
				}

				Sokoban.walls.imgBoxIndex = -1; //每次移动之后，都在最后重置某些属性
			};
		</script>
	</body>

</html>